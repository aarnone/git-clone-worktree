#!/usr/bin/env bash
set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Print colored output
print_error() { echo -e "${RED}ERROR: $1${NC}" >&2; }
print_success() { echo -e "${GREEN}✓ $1${NC}"; }
print_info() { echo -e "${BLUE}→ $1${NC}"; }
print_warning() { echo -e "${YELLOW}⚠ $1${NC}"; }

# Show usage
usage() {
    cat << USAGE
Usage: $(basename "$0") <repository-url> [directory-name]

Clone a git repository and set it up for worktree-based workflow.

Arguments:
    repository-url    Git repository URL (https or ssh)
    directory-name    Optional: Target directory name (defaults to repo name)

Examples:
    $(basename "$0") git@github.com:user/myproject.git
    $(basename "$0") https://github.com/user/myproject.git myproject
    $(basename "$0") git@github.com:user/myproject.git ~/projects/myproject

What this script does:
    1. Creates directory structure with .bare/ subdirectory
    2. Clones repository as bare into .bare/
    3. Sets up .git file to point to .bare/
    4. Configures remote tracking for fetches
    5. Creates initial worktree for default branch
    6. Displays next steps

Directory structure created:
    myproject/
    ├── .bare/          # Git repository (hidden)
    ├── .git            # Pointer file to .bare/
    └── main/           # First worktree (default branch)
USAGE
    exit 1
}

# Check if git is installed
if ! command -v git &> /dev/null; then
    print_error "git is not installed"
    exit 1
fi

# Parse arguments
if [[ $# -lt 1 ]] || [[ $# -gt 2 ]]; then
    usage
fi

REPO_URL="$1"
DIR_NAME="${2:-}"

# Extract repository name from URL if directory not specified
if [[ -z "$DIR_NAME" ]]; then
    # Extract last part of URL and remove .git extension
    DIR_NAME=$(basename "$REPO_URL" .git)
fi

# Expand ~ to home directory if present
DIR_NAME="${DIR_NAME/#\~/$HOME}"

# Check if directory already exists
if [[ -d "$DIR_NAME" ]]; then
    print_error "Directory '$DIR_NAME' already exists"
    exit 1
fi

print_info "Setting up worktree repository: $DIR_NAME"
echo

# Create main directory
print_info "Creating directory structure..."
mkdir -p "$DIR_NAME"
cd "$DIR_NAME"
BASE_DIR=$(pwd)

# Clone as bare repository
print_info "Cloning repository as bare..."
if ! git clone --bare "$REPO_URL" .bare; then
    print_error "Failed to clone repository"
    cd ..
    rm -rf "$DIR_NAME"
    exit 1
fi

print_success "Repository cloned to .bare/"

# Create .git file pointing to .bare
print_info "Creating .git pointer..."
echo "gitdir: ./.bare" > .git
print_success "Created .git pointer to .bare/"

# Configure remote fetch
print_info "Configuring remote tracking..."
git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
print_success "Remote tracking configured"

# Enable ref logs (useful for debugging)
print_info "Enabling reflog..."
git config core.logAllRefUpdates true
print_success "Reflog enabled"

# Determine default branch from remote without fetching all branches
print_info "Detecting default branch..."
DEFAULT_BRANCH=""

# Try to get default branch from remote using ls-remote (doesn't create local branches)
DEFAULT_BRANCH=$(git ls-remote --symref origin HEAD | awk '/^ref:/ {sub(/refs\/heads\//, "", $2); print $2}' || true)

# Fallback: try GitHub CLI if available
if [[ -z "$DEFAULT_BRANCH" ]] && command -v gh &> /dev/null && gh auth status &> /dev/null 2>&1; then
    DEFAULT_BRANCH=$(gh repo view "${REPO_URL}" --json defaultBranchRef -q .defaultBranchRef.name 2>/dev/null || true)
fi

# Fallback: check for common branch names
if [[ -z "$DEFAULT_BRANCH" ]]; then
    # Use ls-remote to check without creating local refs
    if git ls-remote --heads origin main | grep -q "refs/heads/main"; then
        DEFAULT_BRANCH="main"
    elif git ls-remote --heads origin master | grep -q "refs/heads/master"; then
        DEFAULT_BRANCH="master"
    fi
fi

if [[ -z "$DEFAULT_BRANCH" ]]; then
    print_error "Could not determine default branch"
    print_info "You can manually check branches with: git ls-remote --heads origin"
    exit 1
fi

print_success "Default branch detected: $DEFAULT_BRANCH"

# Fetch only the default branch
print_info "Fetching $DEFAULT_BRANCH..."
if ! git fetch origin "$DEFAULT_BRANCH"; then
    print_error "Failed to fetch $DEFAULT_BRANCH"
    exit 1
fi
print_success "Fetched $DEFAULT_BRANCH"

# Create first worktree for default branch
# Git automatically sets up tracking when path matches remote branch name
print_info "Creating worktree for $DEFAULT_BRANCH..."
if ! git worktree add "$DEFAULT_BRANCH"; then
    print_error "Failed to create worktree"
    exit 1
fi

print_success "Worktree created at $DEFAULT_BRANCH/ (tracking origin/$DEFAULT_BRANCH)"
print_info "Only $DEFAULT_BRANCH was fetched - other branches created on-demand"

echo
print_success "Repository setup complete!"
echo
echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "${GREEN}Repository Location:${NC} $BASE_DIR"
echo -e "${GREEN}Default Branch:${NC} $DEFAULT_BRANCH"
echo
echo -e "${YELLOW}Next Steps:${NC}"
echo
echo "  # Navigate to the default branch worktree"
echo "  cd $DIR_NAME/$DEFAULT_BRANCH"
echo
echo "  # Create a NEW feature worktree and branch"
echo "  cd $DIR_NAME"
echo "  git worktree add feature-name -b feature-name"
echo
echo "  # Create worktree from EXISTING remote branch (fetches on-demand)"
echo "  git worktree add existing-feature origin/existing-feature -b existing-feature"
echo
echo "  # List all worktrees"
echo "  git worktree list"
echo
echo "  # List available remote branches (doesn't create local branches)"
echo "  git ls-remote --heads origin"
echo
echo "  # Remove a worktree when done"
echo "  git worktree remove feature-name"
echo
echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo
echo -e "${YELLOW}Directory Structure:${NC}"
tree -L 2 -a "$BASE_DIR" 2>/dev/null || ls -la "$BASE_DIR"
